### lec13 lab4 内核线程管理

#### 总体介绍
- 目标：了解内核线程创建/执行的管理过程
	- 前面的实验：解决内存管理问题，包括物理内存管理，虚拟内存管理
	- 问题：对CPU而言，怎样充分利用CPU，让CPU执行多个不同的线程或进程
	- 线程：在内核中创建一个线程比在用户态创建进程要容易一些
	- 线程的生命周期：启动，就绪，执行，等待，退出
	- 怎么有效管理生命周期：在操作系统里面使用专门的数据结构TCB（线程控制块）管理
- 目标：了解内核线程的切换和基本调度过程
	- 线程需要管理代码段、数据段、执行流程，需要直到它在某一个时刻执行到什么地方，也就是说对于这个线程执行过程，希望有效管理措施，可以使得多线程和单线程都可以在系统里面正常工作
	- 对单线程涉及不到调度，在多线程就会碰到到底在什么时候让线程占用CPU执行的问题
- 练习：分配并初始化一个进程控制块
	- 控制块用于管理线程的占用空间、占用堆栈等等
- 练习：为新创建的内核线程分配资源
- 练习：理解如何完成进程切换
- 流程概述
	- 处理数据结构：1.TCB，2.TCB列表(list)
	- 操作：lab1~lab3的初始化（虚拟内存初始化之类的）-内核线程初始化-创建内核线程（分配资源）-切换并执行内核线程

#### 关键数据结构
- TCB(thread control block)包括：
- 身份标识：pid和它自己的名字(name)
- 运行时与调度相关的管理控制信息（动态）：
	- 当前所处状态(state)
	- 是否需要调度，run flags
- 内存管理相关（线程需要的内存资源）：
	- kstack（内核线程所以有内核堆栈，到lab5的时候讲用户进程，也有内核堆栈）
	- CR3（不怎么用，因为用进程的一个页表来共享地址空间，对内核线程而言，对应的进程就是操作系统ucore，在lab1和lab2时建立的页表就会由内核线程使用，即内核线程共用了ucore内核的页表）
	- mm（管理线程或进程所需要的内存空间。进程需要合法内存空间，每个合法内存空间块用vma表示。对内核线程而言这块是不需要的，因为它在ucore管理之下。所以这些vma都属于同一进程的mm结构来管理。所有的vma本身形成一个list，是对内存空间的管理，对lab4可忽略）
- 硬件相关：
	- context（线程或进程的上下文，即进程运行时所处的状态，对80386而言即eip,esp,ebx,ecx,edx,esi,edi,ebp寄存器。注意context比state更详细）
	- trapframe（lab1中断使用到trapfrme，创建线程时需要对它做相应设置）。trapframe包括：
	- 第一部分：err,eip,cs,padding4,eflags；
	- 第二部分：esp，ss，padding5.这些由硬件放到寄存器中，在特权级切换时会把esp和ss压入栈，即第二部分是硬件在切换特权级时要去压栈的信息，为lab5实现用户级进程做好准备工作；
	- 第三部分：段寄存器的信息+通用寄存器的信息，由软件保存，注意硬件保存前两部分信息，软件保存第三部分信息。trapframe保存了它被打断的进程或线程当前状态
	- context用于进程切换，trapframe是在中断时保存现场状态。context的保存都是软件做的，而中断产生的时候硬件会做一些寄存器报错，但是它做的不完整，所以需要os后续处理，所以需要trapframe
- 一些list：父进程的信息，两个link（形成双向链表），建立hash值list方便查询

#### 执行流程
- ucore os执行kern_init，进一步调用跟进程相关的proc_init，完成一系列的任务，重点注意proc_init和do_fork，它们涉及到进程创建和执行的细节和信息
- 创建流程：
- 创建0号内核线程idleproc，代表ucore os完成一系列的管理工作（包括后面完成的内核线程init proc创建和调度执行过程）
	- 自身的初始化过程（创建自己的TCB，需要alloc_proc来得到一个TCB内存块）
	- TCB内存块的初始化包括设定pid为0，state为runnable（就绪态），kstack为bootstack，need_resched为1（需要被调度，由它切换到其它线程执行），设置name为idle
- 创建一个能显示字符串的内核线程
	- 使用do_fork完成后续的初始化工作






