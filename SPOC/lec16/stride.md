进程的 stride 值是 uint32_t 类型的，可以把 0~(2^32-1) 的所有整数绕成一个环，如下图所示（假定下图是一个环）：

```
顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |    0   |    1   |    2   |    3   |  ...   | 2^31-1 |  2^31  | 2^31+1 |  ...   | 2^32-2 | 2^32-1 |    0   |    1   |    2   |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----
```

进程的 stride 可能有如下两种操作：

(1) 一个进程的前进：stride += pass

(2) 两个进程的比较：(int32_t) (stride1 - stride2) > 0

我们可以将所有进程放置在上面的环上，位置由 stride 值给定，那么上述两种操作就可以进行转化：

(1) 一个进程的前进：相当于当前进程在环上顺时针前进 pass 步

```
例：stride = 1  pass = 2

移动前：

顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |    0   |    A   |        |        |  ...   |        |  2^31  |        |  ...   |        | 2^32-1 |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----


移动后：

顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |    0   |        |        |    A   |  ...   |        |  2^31  |        |  ...   |        | 2^32-1 |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----
```

(2) 两个进程的比较：为此需要定义圆环上的距离 dis(A, B)，即进程 A 沿逆时针方向行进至进程 B 所在位置需要的步数。

```
例：A->stride = 1  B->stride = 3

dis(B, A) = 2

顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |        |    x   |    x   |    B   |  ...   |        |  2^31  |        |  ...   |        | 2^32-1 |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----


dis(A, B) = 2^32 - 2

顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |    x   |    A   |        |    x   |  ...   |    x   |    x   |    x   |  ...   |    x   |    x   |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----
```

上述距离函数满足如下性质：

```
1. dis(A, A) = 0
2. 0 < dis(A, B) < 2^32
3. dis(A, B) + dis(B, A) = 2^32
4. dis(A, B) + dis(B, C) = dis(A, C) 或 dis(A, C) + 2^32
```

并且可以验证：

```
1. dis(A, B) = (uint32_t) (A->stride - B->stride)

2. (int32_t) (A->stride - B->stride) > 0
<=> (uint32_t) (A->stride - B->stride) < 2^31
<=> dis(A, B) < 2^31
<=> dis(A, B) < dis(B, A)
```

因此比较两个进程的 stride，可以通过等价的 dis(A, B) < 2^31 或 dis(A, B) < dis(B, A) 来判断，该条件满足意味着 B 的进度落后于 A。

通过上面的转化，我们就可以把 Stride 调度算法在圆环上模拟出来。


剩下的问题在于，为什么要保证步进值 pass <= PASS_MAX = 2^31 - 1 。

首先证明，pass <= M 等价于 STRIDE_MAX - STRIDE_MIN <= M，其中 M < 2^32。

```
例：

顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |        |   MIN  |        |        |   C1   |        |   MAX  |        |        |        |        |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----           |                                            |
                    Tail                                          Head
```

```
在圆环上标出 STRIDE_MAX 和 STRIDE_MIN 的位置，记为 MAX 和 MIN，那么 STRIDE_MAX - STRIDE_MIN <= M 等价于 dis(MAX, MIN) <= M。

1. 如果 pass <= M，并且当前状态满足 STRIDE_MAX - STRIDE_MIN <= M。

现在让处于 MIN 的进程前进 pass 来到 C1，那么 dis(MAX, C1) + dis(C1, MIN) = dis(MAX, MIN) 或 dis(MAX, MIN) + 2^32。

若 dis(MAX, C1) + dis(C1, MIN) = dis(MAX, MIN) + 2^32，那么由于 dis(C1, MIN) = pass <= M，