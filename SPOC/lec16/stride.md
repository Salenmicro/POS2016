进程的 stride 值是 uint32_t 类型的，可以把 0~(2^32-1) 的所有整数绕成一个环，如下图所示（假定下图是一个环）：

```
顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |    0   |    1   |    2   |    3   |  ...   | 2^31-1 |  2^31  | 2^31+1 |  ...   | 2^32-2 | 2^32-1 |    0   |    1   |    2   |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----
```

进程的 stride 可能有如下两种操作：

(1) 一个进程的前进：stride += pass

(2) 两个进程的比较：(int32_t) (stride1 - stride2) > 0

我们可以将所有进程放置在上面的环上，位置由 stride 值给定，那么上述两种操作就可以进行转化：

(1) 一个进程的前进：相当于当前进程在环上顺时针前进 pass 步

```
例：stride = 1  pass = 2

移动前：

顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |    0   |    A   |        |        |  ...   |        |  2^31  |        |  ...   |        | 2^32-1 |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----


移动后：

顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |    0   |        |        |    A   |  ...   |        |  2^31  |        |  ...   |        | 2^32-1 |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----
```

(2) 两个进程的比较：为此需要定义圆环上的距离 dis(A, B)，即进程 A 沿逆时针方向行进至进程 B 所在位置需要的步数。

```
例：A->stride = 1  B->stride = 3

dis(B, A) = 2

顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |        |    x   |    x   |    B   |  ...   |        |  2^31  |        |  ...   |        | 2^32-1 |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----


dis(A, B) = 2^32 - 2

顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |    x   |    A   |        |    x   |  ...   |    x   |    x   |    x   |  ...   |    x   |    x   |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----
```

上述距离函数满足如下性质：

```
1. dis(A, A) = 0
2. 0 < dis(A, B) < 2^32
3. 当且仅当 A 不等于 B 时，dis(A, B) + dis(B, A) = 2^32
4. dis(A, B) + dis(B, C) = dis(A, C) 或 dis(A, C) + 2^32
```

并且可以验证：

```
1. dis(A, B) = (uint32_t) (A->stride - B->stride)

2. (int32_t) (A->stride - B->stride) > 0
<=> (uint32_t) (A->stride - B->stride) < 2^31
<=> dis(A, B) < 2^31
<=> dis(A, B) < dis(B, A) 或 dis(A, B) = dis(B, A) = 0
```

因此比较两个进程的 stride，可以通过等价的 dis(A, B) < 2^31，或者 dis(A, B) < dis(B, A) 或 dis(A, B) = dis(B, A) = 0 来判断，该条件满足意味着 B 的进度落后于 A。

通过上面的转化，我们就可以把 Stride 调度算法在圆环上模拟出来。


剩下的问题在于，为什么要保证步进值 pass <= PASS_MAX = 2^31 - 1 。

如果 PASS_MAX >= 2^31，那么我们可以构造出下面的例子：

```
有两个进程 A, B，初始时 A->stride = 0，B->stride = 0，
由于 dis(A, B) = dis(B, A) = 0，假设我们认为 B 的进度落后于 A（实际上 A 的进度也落后于 B，但算法必然会选择其一），于是 B 前进，并取步进值 pass = 2^31，
此时 A->stride = 0，B->stride = 2^31，dis(A, B) = dis(B, A) = 2^31，这时我们无法判断究竟是 A 落后于 B，还是 B 落后于 A，算法失效。
即使算法继续进行下去，有可能 B 会继续前进，并取步进值 pass = 2^31，
这时 A->stride = 0，B->stride = 0，回到初始情况。
也就是说，很有可能进程 B 会执行很长一段时间，而进程 A 会有很长一段时间得不到执行，这时候算法非常不稳定。
``` 

如果 PASS_MAX >= 2^31 + 2，那么我们可以构造出更极端的例子：

```
有两个进程 A, B，初始时 A->stride = 1，B->stride = 0，
由于 dis(A, B) = 1 < 2^31，我们认为 B 的进度落后于 A，于是 B 前进，并取步进值 pass = 2^31 + 2，
此时 A->stride = 1， B->stride = 2^31 + 2，
由于 dis(A, B) = 2^31 - 1 < 2^31，我们认为 B 的进度落后于 A，于是 B 前进，并取步进值 pass = 2^31 - 2，
此时 A->stride = 1， B->stride = 0，回到初始情况。
也就是说，进程 B 将永远执行下去，而进程 A 将永远得不到执行，算法失效。
```

从上述两例中可以看出，算法成立必须满足 PASS_MAX <= 2^31 - 1。

```
引理： PASS_MAX <= M 等价于 STRIDE_MAX - STRIDE_MIN <= M，其中 M < 2^32（仅以图例说明，不严格证明）。

例：

顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |        |  C_MIN |        |        |   C1   |        |  C_MAX |        |        |        |        |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----           |                                            |
                    Tail                                          Head

顺时针 ---->
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
   ...  |        |  C_MIN |        |        |        |        |  C_MAX |        |   C1   |        |        |  ...
--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------
逆时针 <----           |                                            |                |
                    Tail                                          Head             Head1

在圆环上标出 STRIDE_MAX 和 STRIDE_MIN 的位置，对应的进程为 C_MAX 和 C_MIN，那么 STRIDE_MAX - STRIDE_MIN <= M 等价于 dis(MAX, MIN) <= M。并且假定 Stride 算法选择了位于 C_MIN 的进程，前进 pass 来到了 C1。

1. 假设 STRIDE_MAX - STRIDE_MIN <= M，如果 pass > M，那么就可以构造反例，考虑一种情形，C_MIN 处有另外一个进程 C_MIN1，则 dis(C1, C_MIN) = pass > M，这时不满足 dis(C1_MAX, C1_MIN) <= M，因此 pass <= M，即 PASS_MAX <= M。

2. （非严格证明）假设 pass <= M，并且当前状态满足 STRIDE_MAX - STRIDE_MIN <= M。当 C_MIN 前进后，可能会出现上述两种情况，这意味着 C_MAX1 = C_MAX 或者 C1，无论哪种情况都满足 dis(C1_MAX, C1_MIN) <= M
```

实际上，在 PASS_MAX <= 2^31 - 1 的情况下，根据上述引理，dis(C_MAX, C_MIN) < 2^31，我们一定可以保证算法判断 C_MIN 落后于 C_MAX，对于 C_MIN 和 C_MAX 之间的进程也是如此。这样一来，所有进程就会得到交替执行，算法成功。

在 PASS_MAX >= 2^31 的情况下，有可能 dis(C_MAX, C_MIN) >= 2^31，这时我们不能保证算法判断 C_MIN 落后于 C_MAX，算法失效。
