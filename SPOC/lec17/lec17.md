如果没有 while choosing[j] 这一条语句的话，我们考虑两个进程 P0 和 P1，其中 P0 的 pid 值比 P1 小，

初始时 num[0] = num[1] = 0。

P0 在计算完 max = 0 后，切换到进程 P1 执行，进程 P1 计算出 max = 0 并得到 num[1] = 1，在 while 循环中，由于 num[0] = 0，所以 P1 顺利进入临界区执行。

然后 P0 计算出 num[0] = 1，而 P0 的 pid 值比 P1 小，这样 P0 也进入临界区进行执行，这就导致 “忙则等待” 没有得到满足。

但是如果加上 while choosing[j] 这一条语句之后，进程 P1 就会先堵塞在 while choosing[j]，待进程 P0 计算出 num[0] = 1 之后，P1 就不会进入临界区执行了。
