###课堂笔记

###计算机体系结构和内存层次
- 操作系统在内存中存储
####操作系统的内存管理
- 抽象（逻辑地址空间）
- 共享（使用同样的逻辑地址空间）（访问通用内存）
- 保护（各进程直接互不影响）（地址空间独立）
- 虚拟化（更大的地址空间）
####操作系统的内存管理方式
- 重定位
- 分段（代码段、数据段、堆栈段）（每段内容连续）
- 分页
	- 把内存分成最基本的单位（比直接用1个字节管理难度低）
- 虚拟存储（逻辑地址大于物理地址）

###地址空间&地址生成
- 物理地址空间：硬件支持的地址空间（多少位地址总线就有多大空间）
	- 物理地址编号唯一，而程序希望使用同样的地址，故虚拟化位逻辑地址空间
- 逻辑地址空间：在CPU运行时的进程看到的空间
- 逻辑地址生成：编译成汇编->汇编确定跳转地址（call或jump）->将函数库与程序线性放在一起（此时是逻辑地址）->程序加载时重定位到物理地址
- 几种生成地址时机和限制
	- 编译时生成：起始地址已知，一旦起始地址改变就要重新编译程序（编译时写死地址，导致后续程序无法加入，见于过去的非智能手机）
	- 加载时生成：编译时起始地址位置，编译器需要生成可重定位的代码，加载时生成绝对地址（允许加载到不同地方，可以加入后续程序，需要做重定位，通过重定位表实现）
	- 执行时生成：执行到跳转类指令时才生成绝对地址，使得执行时代码可移动，需要地址转换（映射）硬件支持（出现在虚拟类存储里面）（程序在执行过程中物理存储的位置可以挪动，前两种都要求地址空间连续而且运行时地址不可变，这种更灵活，但是没有前两种简单）
- 地址生成过程
	- CPU将一个地址给MMU，MMU根据页表把地址翻译成物理地址，CPU的控制器把物理地址和控制信号给总线，总线把信号和地址给内存，然后进行对应处理
	- 硬件：CPU完成地址转换（而不是软件）
	- 软件：地址转换表由操作系统完成（页表）
- 地址检查
	- 得到逻辑地址后要先判断偏移量是否超过段长度，超过则指令执行失败进行相应处理
	- 操作系统可以设置段基址和段长度（软件控制地址检查）

###连续内存分配
####最先匹配策略
- 原理：
	- 空闲分区列表按地址顺序排列
	- 分配过程时搜索一个合适的分区
	- 释放分区时，检查是否可与临近的空闲分区合并
	- 在空闲分区找到第一个可用分区就使用
- 优点：
	- 简单
	- 在高地址空间有大块的空闲分区
- 缺点：
	- 外碎片多
	- 分配大块时比较慢

####最佳匹配策略
- 原理：
	- 空闲分区按照大小排序
	- 分配时，查找一个合适的分区
	- 释放时，查找并且合并临近的空闲分区
	- 在所有空闲分区中找最小的合适分区
- 优点：
	- 大部分分配的尺寸较小时效果很好
	- 可以避免大的空闲分区被拆分
	- 可以减小外部碎片的大小
	- 相对简单
- 缺点：
	- 外部碎片
	- 释放分区较小
	- 容易产生很多无用的小碎片

####最差匹配策略
- 原理：
	- 空闲分区按大到小排序
	- 分配时选最大的分区
	- 释放时检查是否与临近空闲分区合并，进行合并，并调整空闲分区列表顺序
- 优点：
	- 中等大小分配多时效果最好
	- 避免出现太多小碎片
- 缺点：
	- 释放分区较慢（因为查找空闲分区时排序，而合并空闲分区时需要找临近分区）
	- 外部碎片
	- 容易破坏大的空闲分区，后续难以分配大的分区

###碎片整理
通过调整已经分配给进程的内存分区它的位置来减少碎片
####紧凑
- 通过移动分配给进程的内存分区来合并外部碎片
	- 不能随便动，因为要考虑中间可能调用绝对地址
- 条件
	- 所有进程都可以动态重定位
	- 不可以在正在运行的时候移动（处于等待状态时移动）
	- 要考虑开销（没必要为了一小块空闲空间来移动一大堆进程）
####分区对换
- 通过抢占并回收处于等待状态进程的分区来增加可用内存空间
	- 抢到的进程原先的数据放入外存中（也就是换到对换区）
	- unix系统有个分区叫对换区，就是做这个用途（任何一个时刻只有一个进程在内存中运行，通过将当前进程对换到对换区的方式来实现切换进程）（开销很大，因为外存慢）

###伙伴系统
- 连续内存分配的实例
	- 折中了分配和回收过程中的合并和分配块的位置、碎片的问题
- 原理
	- 把整个可以分配的分区大小约定为是2的幂（2^u）
	- 任何一块要分的时候把它从中间切开，不会以其它方式切
	- 需要的分区大小为2^u<s<=2^u时把整个块分配给该进程，否则二分该块
	- 也就是如果最小块的1/2比你还要大，就递归切小块
	- 内碎片最大为需要的分区大小s/2-1
	- 合并时也要遵守每块大小是2的幂
	- 合并时不需要移动，只合并相邻块
- 数据结构
	- 空闲块按大小和起始地址组织成二维数组，第一维是空闲块的大小，从小到大排成第一维，相同大小的空间块按地址排序排成第二维
	- 初始是只有一个大小为2^u的空闲块
	- 分配时由小到大在空闲块数组中找最小的可用空闲块
	- 如果空闲块过大就递归二分该块
- linux和unix都有buddy system的实现，做内核的存储分配
- ucore中的伙伴系统

